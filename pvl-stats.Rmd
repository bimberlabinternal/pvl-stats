Labkey setup
```{r setup, include=FALSE}
library(Rdiscvr)
library(dplyr)
library(Rlabkey)
library(forecast)
library(scales)
library(pracma)
library(ggplot2)
library(patchwork)
library(officer)

knitr::opts_chunk$set(echo = TRUE)

Rdiscvr::SetLabKeyDefaults(baseUrl = 'https://prime-seq.ohsu.edu', defaultFolder = '/Labs/Bimber')
```

```{r}
.AppendSummaryRow <- function(id, date, outcome, numeric_value = NA, string_value = NA, comment = NA, data_source = NA) {
  if (is.na(numeric_value) && is.na(string_value)) {
    return(NULL)
  }

  tibble::tibble(
    id = id,
    date = date,
    outcome = outcome,
    numericValue = numeric_value,
    stringValue = string_value,
    comments = comment,
    datasource = data_source
  )
}

# Compute chronic phase viral load setpoints and plot the trajectory.
#
# This function calculates two geometric mean setpoints from 8–16 weeks post-infection:
# - Acute setpoint (if ART has not started)
# - Post-ART setpoint (if ART has been initiated) or Chronic setpoint (if no ART)
#
# It requires a minimum number of points and a minimum time span for each window.
# The function also computes a partial autocorrelation score (PACF) for acute values
# and produces a line plot with ART annotations, chronic window bounds, and setpoint lines.
#
# Adds columns: Acute_Setpoint, Chronic_Setpoint, Setpoint_PACF
# Prints: log-scaled viral load plot with annotations
.ChronicPhaseSetpoint <- function(df = NULL, minPoints = 4, minDaysDuration = 7) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      log10_pvl = log10(result),
      hasART_flag = !is.na(artinformation_dayspostartinitiation),
      art_initiation_dpi = as.numeric(artinformation_artinitiation - timepostsivchallenge_infectiondate),
      art_release_dpi    = as.numeric(artinformation_artrelease    - timepostsivchallenge_infectiondate)
    )

  subject_has_ART <- any(df$hasART_flag, na.rm = TRUE)

  acute_df <- df %>%
    filter(timepostsivchallenge_dayspostinfection < 56,
           timepostsivchallenge_dayspostinfection > 0)

  chronic_df <- df %>%
    filter(timepostsivchallenge_dayspostinfection >= 56,
           timepostsivchallenge_dayspostinfection <= 112)

  id          <- unique(df$id)
  date        <- suppressWarnings(min(df$date, na.rm = TRUE))
  data_source <- df$datasource[1]
  summary_outcomes <- list()

  if (nrow(acute_df) >= minPoints &&
      (max(acute_df$timepostsivchallenge_dayspostinfection) -
       min(acute_df$timepostsivchallenge_dayspostinfection)) >= minDaysDuration) {

    acute_setpoint <- exp(mean(log(acute_df$result)))
    acute_pacf     <- pacf(log10(acute_df$result), plot = FALSE)$acf[1]

    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "acutePhaseSetpoint",     numeric_value = acute_setpoint, data_source = data_source),
      .AppendSummaryRow(id, date, "acutePhaseSetpointPACF", numeric_value = acute_pacf,     data_source = data_source)
    ))
  }

  if (subject_has_ART) {
    # Post-ART setpoint: only chronic-window rows that have the ART flag
    post_art_df <- chronic_df %>% dplyr::filter(coalesce(hasART_flag, FALSE))
    if (nrow(post_art_df) >= minPoints &&
        (max(post_art_df$timepostsivchallenge_dayspostinfection) -
         min(post_art_df$timepostsivchallenge_dayspostinfection)) >= minDaysDuration) {

      postART_setpoint <- exp(mean(log(post_art_df$result)))

      summary_outcomes <- append(summary_outcomes, list(
        .AppendSummaryRow(id, date, "postARTSetpoint", numeric_value = postART_setpoint, data_source = data_source)
      ))
    }
  } else {
    # No ART: chronic-phase setpoint from all chronic-window rows
    if (nrow(chronic_df) >= minPoints &&
        (max(chronic_df$timepostsivchallenge_dayspostinfection) -
         min(chronic_df$timepostsivchallenge_dayspostinfection)) >= minDaysDuration) {

      chronicPhase_setpoint <- exp(mean(log(chronic_df$result)))

      summary_outcomes <- append(summary_outcomes, list(
        .AppendSummaryRow(id, date, "chronicPhaseSetpoint", numeric_value = chronicPhase_setpoint, data_source = data_source)
      ))
    }
  }

  gg <- ggplot(df, aes(x = timepostsivchallenge_dayspostinfection, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(color = "grey70", size = 2) +
    scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    geom_vline(data = df %>% filter(!is.na(art_initiation_dpi)),
               aes(xintercept = art_initiation_dpi), linetype = "dashed", color = "blue") +
    geom_vline(data = df %>% filter(!is.na(art_release_dpi)),
               aes(xintercept = art_release_dpi), linetype = "dashed", color = "red") +
    geom_vline(xintercept = 56,  linetype = "dotted", color = "darkgreen", linewidth = 0.8) +
    geom_vline(xintercept = 112, linetype = "dotted", color = "darkgreen", linewidth = 0.8) +
    geom_point(data = acute_df,
               aes(x = timepostsivchallenge_dayspostinfection, y = result),
               shape = 21, fill = "blue", color = "black", size = 3, inherit.aes = FALSE) +
    geom_point(
      data = if (subject_has_ART) (chronic_df %>% dplyr::filter(coalesce(hasART_flag, FALSE))) else chronic_df,
      aes(x = timepostsivchallenge_dayspostinfection, y = result),
      shape = 21, fill = "red", color = "black", size = 3, inherit.aes = FALSE
    ) +
    labs(
      title = paste0("Acute (0–56) and Chronic-Window (56–112) Setpoints for ", unique(df$id)),
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection"
    ) +
    annotate("text", x = 56,
             y = min(df$result[df$result > 0], na.rm = TRUE),
             label = "8 weeks", angle = 90, vjust = 1.2, hjust = 0,
             color = "darkgreen", size = 3.5) +
    annotate("text", x = 112,
             y = min(df$result[df$result > 0], na.rm = TRUE),
             label = "16 weeks", angle = 90, vjust = 1.2, hjust = 0,
             color = "darkgreen", size = 3.5) +
    theme_minimal()

  if (exists("acute_setpoint") && !is.na(acute_setpoint)) {
    gg <- gg +
      geom_hline(yintercept = acute_setpoint, linetype = "solid", color = "blue", linewidth = 0.4) +
      annotate("text", x = min(df$timepostsivchallenge_dayspostinfection, na.rm = TRUE),
               y = acute_setpoint, label = "Acute-Phase Setpoint", hjust = -0.1, vjust = -0.5,
               color = "blue", size = 3.5)
  }

  if (subject_has_ART && exists("postART_setpoint") && !is.na(postART_setpoint)) {
    gg <- gg +
      geom_hline(yintercept = postART_setpoint, linetype = "solid", color = "red", linewidth = 0.4) +
      annotate("text", x = min(df$timepostsivchallenge_dayspostinfection, na.rm = TRUE),
               y = postART_setpoint, label = "Post-ART Setpoint", hjust = -0.1, vjust = -0.5,
               color = "red", size = 3.5)
  }

  if (!subject_has_ART && exists("chronicPhase_setpoint") && !is.na(chronicPhase_setpoint)) {
    gg <- gg +
      geom_hline(yintercept = chronicPhase_setpoint, linetype = "solid", color = "red", linewidth = 0.4) +
      annotate("text", x = min(df$timepostsivchallenge_dayspostinfection, na.rm = TRUE),
               y = chronicPhase_setpoint, label = "Chronic-Phase Setpoint", hjust = -0.1, vjust = -0.5,
               color = "red", size = 3.5)
  }

  # ART text labels (if present)
  art_initiation_x <- df %>% filter(!is.na(art_initiation_dpi)) %>% distinct(art_initiation_dpi) %>% pull()
  art_release_x    <- df %>% filter(!is.na(art_release_dpi))    %>% distinct(art_release_dpi)    %>% pull()

  if (length(art_initiation_x) > 0) {
    gg <- gg + annotate("text", x = art_initiation_x[1],
                        y = min(df$result[df$result > 0], na.rm = TRUE),
                        label = "ART Initiation", angle = 90, vjust = 1.2, hjust = 0,
                        color = "blue", size = 3.5)
  }
  if (length(art_release_x) > 0) {
    gg <- gg + annotate("text", x = art_release_x[1],
                        y = min(df$result[df$result > 0], na.rm = TRUE),
                        label = "ART Release", angle = 90, vjust = 1.2, hjust = 0,
                        color = "red", size = 3.5)
  }

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}




# Identify acute phase peak viral load and plot the trajectory.
#
# This function finds the maximum viral load within the first `window_days` post-infection.
# It flags whether ART was initiated before that peak, adds relevant columns to the dataframe,
# and prints a line plot with the peak point and acute window annotated.
#
# Adds columns: AcutePhasePeak_pVL, AcutePhasePeak_ARTBeforePeak
# Prints: log-scaled viral load plot with peak highlight and window boundary
.AcutePhasePeak <- function(df, window_days = 35) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      art_initiation_dpi = as.numeric(artinformation_artinitiation - timepostsivchallenge_infectiondate)
    )

  acute_df <- df %>%
    filter(timepostsivchallenge_dayspostinfection <= window_days)

  id <- unique(df$id)
  date <- min(df$date, na.rm = TRUE)
  data_source <- df$datasource[1]

  summary_outcomes <- list()

  if (nrow(acute_df) > 0) {
    peak_row <- acute_df %>%
      filter(result == max(result, na.rm = TRUE)) %>%
      slice(1)

    acute_peak <- peak_row$result
    acute_peak_day <- peak_row$timepostsivchallenge_dayspostinfection
    art_before_peak <- !is.na(peak_row$art_initiation_dpi) &&
      peak_row$art_initiation_dpi <= acute_peak_day

    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "acutePhasePeak_pVL", numeric_value = acute_peak, data_source = data_source),
      .AppendSummaryRow(id, date, "acutePhasePeak_day", numeric_value = acute_peak_day, data_source = data_source)
    ))

  } else {
    art_before_peak <- NA
  }

  df$AcutePhasePeak_ARTBeforePeak <- art_before_peak

  gg <- ggplot(df, aes(x = timepostsivchallenge_dayspostinfection, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(color = "grey70", size = 2) +
    scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
    labs(
      title = paste0("Acute Phase Peak pVL for ", unique(df$id)),
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection"
    ) +
    theme_minimal()

  gg <- gg +
    geom_vline(xintercept = window_days, linetype = "dotted", color = "darkgreen", linewidth = 0.8) +
    annotate("text", x = window_days, y = min(df$result[df$result > 0], na.rm = TRUE),
             label = paste0(window_days, "d"), angle = 90, vjust = 1.2, hjust = 0,
             color = "darkgreen", size = 3.5)

  if (exists("acute_peak_day") && !is.na(acute_peak_day)) {
    gg <- gg +
      geom_point(data = peak_row, 
                 aes(x = timepostsivchallenge_dayspostinfection, y = result),
                 shape = 21, fill = ifelse(art_before_peak, "orange", "purple"),
                 color = "black", size = 4) +
      annotate("text", x = acute_peak_day, y = acute_peak, label = "Peak",
               vjust = -1, hjust = 0.5, size = 3.5)
  }

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}


# Identify and visualize viral blips above LOD during ART.
#
# Flags timepoints where viral load exceeds the limit of detection (LOD) while on ART
# (from ART initiation to ART release). Adds a logical column `OnARTBlip`, counts these blips,
# and visualizes them on a log-scaled viral load time series plot. All distinct LOD values
# within the ART window are shown as hlines.
#
# Adds columns: OnARTBlip, art_initiation_dpi, art_release_dpi
# Prints: Viral load plot with ART timing, LOD lines, and blip highlights
.OnARTBlipFrequency <- function(df) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      daysPostArtInitiation = artinformation_dayspostartinitiation,
      OnARTBlip = ifelse(
        !is.na(daysPostArtInitiation) & daysPostArtInitiation >= 0 &
          !is.na(result) & !is.na(lod) & result > lod,
        TRUE, FALSE
      ),
      art_initiation_dpi = as.numeric(artinformation_artinitiation - timepostsivchallenge_infectiondate),
      art_release_dpi = as.numeric(artinformation_artrelease - timepostsivchallenge_infectiondate)
    )

  blip_count <- sum(df$OnARTBlip, na.rm = TRUE)

  id <- unique(df$id)
  date <- min(df$date, na.rm = TRUE)
  data_source <- df$datasource[1]

  summary_outcomes <- list()
  if (!is.na(blip_count) && blip_count > 0) {
    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "onArtBlipCount", numeric_value = blip_count, data_source = data_source)
    ))
  }

  gg <- ggplot(df, aes(x = timepostsivchallenge_dayspostinfection, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(aes(color = OnARTBlip), size = 2) +
    scale_color_manual(values = c("TRUE" = "red", "FALSE" = "grey70")) +
    scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
    geom_vline(data = df %>% filter(!is.na(art_initiation_dpi)), 
               aes(xintercept = art_initiation_dpi), linetype = "dashed", color = "blue") +
    geom_vline(data = df %>% filter(!is.na(art_release_dpi)), 
               aes(xintercept = art_release_dpi), linetype = "dashed", color = "red") +
    labs(
      title = paste0("On-ART Blip Frequency for ", unique(df$id)),
      subtitle = paste0("Blips above LOD: ", blip_count),
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection",
      color = "Blip > LOD"
    ) +
    theme_minimal()
  
  art_initiation_x <- df %>% filter(!is.na(art_initiation_dpi)) %>% distinct(art_initiation_dpi) %>% pull()
  art_release_x <- df %>% filter(!is.na(art_release_dpi)) %>% distinct(art_release_dpi) %>% pull()

  if (length(art_initiation_x) > 0) {
    gg <- gg + annotate("text", x = art_initiation_x[1],
                        y = min(df$result[df$result > 0], na.rm = TRUE),
                        label = "ART Initiation", angle = 90, vjust = 1.2, hjust = 0,
                        color = "blue", size = 3.5)
  }
  if (length(art_release_x) > 0) {
    gg <- gg + annotate("text", x = art_release_x[1],
                        y = min(df$result[df$result > 0], na.rm = TRUE),
                        label = "ART Release", angle = 90, vjust = 1.2, hjust = 0,
                        color = "red", size = 3.5)
  }
  
  lod_vals <- df %>%
    filter(!is.na(lod), !is.na(art_initiation_dpi), !is.na(art_release_dpi)) %>%
    filter(timepostsivchallenge_dayspostinfection >= art_initiation_dpi,
           timepostsivchallenge_dayspostinfection <= art_release_dpi) %>%
    distinct(lod) %>%
    pull()

  for (lod_y in lod_vals) {
    gg <- gg +
      geom_hline(yintercept = lod_y, linetype = "dashed", color = "darkred") +
      annotate("text",
               x = min(df$timepostsivchallenge_dayspostinfection, na.rm = TRUE),
               y = lod_y,
               label = paste0("LOD (", lod_y, ")"),
               hjust = 0,
               vjust = -0.5,
               color = "darkred",
               size = 3.5)
  }

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}


# Compute and visualize time to viral rebound after ART release.
#
# Calculates the number of days from ART release to first detectable viral load above LOD, 100, and 1000 copies/mL.
# Requires a minimum ART duration (default 7 days) for calculation. Optionally uses the maximum LOD as threshold.
# Highlights rebound timepoints and thresholds on a log-scaled time series plot.
#
# Adds columns: TimeToRebound_LOD, TimeToRebound_100, TimeToRebound_1000
# Prints: Viral load plot with rebound thresholds and annotated rebound timepoints
.TimeToRebound <- function(df, 
                           minARTDuration = 7, 
                           minConsecutivePoints = 1, 
                           lod_floor = TRUE) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      dpi = timepostsivchallenge_dayspostinfection,
      art_initiation_date = artinformation_artinitiation,
      art_release_date = artinformation_artrelease,
      infection_date = timepostsivchallenge_infectiondate,
      art_release_dpi = as.numeric(artinformation_artrelease - timepostsivchallenge_infectiondate)
    )

  id <- unique(df$id)
  date <- min(df$date, na.rm = TRUE)
  data_source <- df$datasource[1]
  summary_outcomes <- list()

  art_timing <- df %>%
    filter(!is.na(art_initiation_date), !is.na(art_release_date)) %>%
    transmute(
      duration = as.numeric(art_release_date - art_initiation_date),
      art_release_dpi = as.numeric(art_release_date - infection_date)
    ) %>%
    distinct()

  if (nrow(art_timing) == 0 || is.na(art_timing$duration[1]) || art_timing$duration[1] < minARTDuration) {
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  art_stop <- art_timing$art_release_dpi[1]

  post_ati <- df %>%
    filter(dpi > art_stop)

  get_rebound_day <- function(df_sub, threshold, art_stop) {
    df_hit <- df_sub %>%
      filter(result > threshold) %>%
      arrange(dpi)
    if (nrow(df_hit) == 0) return(NA)
    df_hit$dpi[1] - art_stop
  }

  lod_val <- if (lod_floor) max(df$lod, na.rm = TRUE) else 0

  rebound_lod   <- get_rebound_day(post_ati, lod_val, art_stop)
  rebound_100   <- get_rebound_day(post_ati, 100, art_stop)
  rebound_1000  <- get_rebound_day(post_ati, 1000, art_stop)

  if (!is.na(rebound_lod)) {
    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "timeToRebound_LOD", numeric_value = rebound_lod, data_source = data_source)
    ))
  }
  if (!is.na(rebound_100)) {
    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "timeToRebound_100", numeric_value = rebound_100, data_source = data_source)
    ))
  }
  if (!is.na(rebound_1000)) {
    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "timeToRebound_1000", numeric_value = rebound_1000, data_source = data_source)
    ))
  }

  get_first_point <- function(threshold) {
    df %>%
      filter(dpi > art_stop, result > threshold) %>%
      slice_min(order_by = dpi, n = 1)
  }

  point_lod <- get_first_point(lod_val)
  point_100 <- get_first_point(100)
  point_1000 <- get_first_point(1000)

  gg <- ggplot(df, aes(x = dpi, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(color = "grey70", size = 2) +
    scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
    geom_vline(xintercept = art_stop, linetype = "dashed", color = "red") +
    geom_hline(yintercept = c(lod_val, 100, 1000), linetype = "dotted", color = "darkgreen") +
    annotate("text", x = min(df$dpi), y = lod_val, label = paste0("LOD (", lod_val, ")"), 
             hjust = 0, vjust = -0.5, color = "darkgreen", size = 3.2) +
    annotate("text", x = min(df$dpi), y = 100, label = "100 copies", 
             hjust = 0, vjust = -0.5, color = "darkgreen", size = 3.2) +
    annotate("text", x = min(df$dpi), y = 1000, label = "1000 copies", 
             hjust = 0, vjust = -0.5, color = "darkgreen", size = 3.2) +
    labs(
      title = paste0("Time to Rebound for ", unique(df$id)),
      subtitle = paste0(
        "To LOD: ", rebound_lod, "d, ",
        ">100: ", rebound_100, "d, ",
        ">1000: ", rebound_1000, "d"
      ),
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection"
    ) +
    theme_minimal()
  
  art_release_x <- df %>% filter(!is.na(art_release_dpi)) %>% distinct(art_release_dpi) %>% pull()

  if (length(art_release_x) > 0) {
    gg <- gg + annotate("text", x = art_release_x[1],
                        y = min(df$result[df$result > 0], na.rm = TRUE),
                        label = "ART Release", angle = 90, vjust = 1.2, hjust = 0,
                        color = "red", size = 3.5)
  }

  highlight_point <- function(point_df, color) {
    if (nrow(point_df) > 0) {
      gg <<- gg +
        geom_point(data = point_df, aes(x = dpi, y = result),
                   shape = 21, fill = color, color = "black", size = 4)
    }
  }

  highlight_point(point_lod, "orange")
  highlight_point(point_100, "purple")
  highlight_point(point_1000, "red")

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}


# Compute and visualize post-rebound viral setpoint.
#
# After ART cessation, calculates geometric mean of viral load starting from a minimum number of days post-release.
# Requires sufficient ART duration, minimum points, and time span to compute the setpoint.
# Adds setpoint and PACF estimate to the data, and highlights the post-rebound phase on a time series plot.
#
# Adds columns: PostReboundSetpoint, PostReboundSetpoint_PACF
# Prints: Viral load plot with post-rebound points and setpoint line
.PostReboundSetPoint <- function(df, 
                                 minARTDuration = 7, 
                                 minPoints = 4, 
                                 minDaysDuration = 7, 
                                 minDaysPostRelease = 14) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      dpi = timepostsivchallenge_dayspostinfection,
      art_initiation_date = artinformation_artinitiation,
      art_release_date = artinformation_artrelease,
      infection_date = timepostsivchallenge_infectiondate,
      art_release_dpi = as.numeric(art_release_date - infection_date)
    )

  id <- unique(df$id)
  date <- min(df$date, na.rm = TRUE)
  data_source <- df$datasource[1]
  summary_outcomes <- list()

  art_timing <- df %>%
    filter(!is.na(art_initiation_date), !is.na(art_release_date)) %>%
    transmute(
      duration = as.numeric(art_release_date - art_initiation_date),
      art_release_dpi = as.numeric(art_release_date - infection_date)
    ) %>%
    distinct()

  if (nrow(art_timing) == 0 || is.na(art_timing$duration[1]) || art_timing$duration[1] < minARTDuration) {
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  art_stop <- art_timing$art_release_dpi[1]

  post_rebound_df <- df %>%
    filter(dpi > (art_stop + minDaysPostRelease)) %>%
    arrange(dpi)

  if (nrow(post_rebound_df) >= minPoints &&
      (max(post_rebound_df$dpi) - min(post_rebound_df$dpi)) >= minDaysDuration) {
    post_rebound_setpoint <- exp(mean(log(post_rebound_df$result)))
    pacf_val <- pacf(log10(post_rebound_df$result), plot = FALSE)$acf[1]

    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "postReboundSetpoint", numeric_value = post_rebound_setpoint, data_source = data_source),
      .AppendSummaryRow(id, date, "postReboundSetpointPACF", numeric_value = pacf_val, data_source = data_source)
    ))
  }

  y_label_pos <- min(df$result[df$result > 0], na.rm = TRUE) * 1.5

  gg <- ggplot(df, aes(x = dpi, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(color = "grey70", size = 2) +
    scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
    geom_vline(xintercept = art_stop, linetype = "dashed", color = "red") +
    geom_point(data = post_rebound_df, aes(x = dpi, y = result),
               shape = 21, fill = "purple", color = "black", size = 3) +
    labs(
      title = paste0("Post-Rebound Setpoint for ", unique(df$id)),
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection"
    ) +
    annotate("text", x = art_stop,
             y = min(df$result[df$result > 0], na.rm = TRUE),
             label = "ART Release", angle = 90, vjust = 1.2, hjust = 0,
             color = "red", size = 3.5) +
    theme_minimal()

  if (exists("post_rebound_setpoint") && !is.na(post_rebound_setpoint)) {
    gg <- gg +
      geom_hline(yintercept = post_rebound_setpoint, linetype = "solid", color = "purple", linewidth = 0.4) +
      annotate("text", x = min(df$dpi, na.rm = TRUE),
               y = post_rebound_setpoint, label = "Post-Rebound Setpoint", hjust = -0.1, vjust = -0.5,
               color = "purple", size = 3.5)
  }

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}


# Compute and visualize acute phase viral burden (AUC).
#
# Calculates the area under the plasma viral load curve (AUC) from infection (dpi 0) to a defined cutoff (default 56 dpi).
# Requires at least 2 data points in the acute window.
# Adds AUC as a new column and overlays the acute phase area on the viral load time series plot.
#
# Adds column: AcutePhaseBurden
# Prints: Line plot with shaded area under the curve during the acute phase
.AcutePhaseBurden <- function(df, acute_cutoff = 56) {
  if (is.null(df) || nrow(df) == 0) {
    warning("Input dataframe is NULL or empty")
    return(list(df = df, summary = tibble(), plot = NULL))
  }

  df <- df %>%
    mutate(
      dpi = timepostsivchallenge_dayspostinfection
    )

  acute_df <- df %>%
    filter(dpi >= 0, dpi <= acute_cutoff) %>%
    arrange(dpi)

  id <- unique(df$id)
  date <- min(df$date, na.rm = TRUE)
  data_source <- df$datasource[1]
  summary_outcomes <- list()

  if (nrow(acute_df) >= 2) {
    auc <- trapz(acute_df$dpi, acute_df$result)

    summary_outcomes <- append(summary_outcomes, list(
      .AppendSummaryRow(id, date, "acutePhaseBurden", numeric_value = auc, data_source = data_source)
    ))
  }

  gg <- ggplot(df, aes(x = dpi, y = result)) +
    geom_line(aes(group = id), color = "grey60") +
    geom_point(color = "grey70", size = 2) +
    geom_area(data = acute_df, aes(x = dpi, y = result), fill = "blue", alpha = 0.3) +
    geom_vline(xintercept = acute_cutoff, linetype = "dotted", color = "darkgreen", linewidth = 0.8) +
    annotate("text", x = acute_cutoff,
             y = min(df$result[df$result > 0], na.rm = TRUE),
             label = paste0(acute_cutoff, " dpi"), angle = 90, vjust = 1.2, hjust = 0,
             color = "darkgreen", size = 3.5) +
    scale_y_log10(labels = trans_format("log10", math_format(10^.x))) +
    labs(
      title = paste0("Acute Phase Burden for ", unique(df$id)),
      subtitle = if (exists("auc")) paste0("AUC (0–", acute_cutoff, " dpi): ", round(auc, 1)) else NULL,
      y = "Plasma Viral Load (copies/mL)",
      x = "Days Post Infection"
    ) +
    theme_minimal()

  return(list(
    df = df,
    summary = dplyr::bind_rows(summary_outcomes),
    plot = gg
  ))
}


.GetData <- function(id = NULL) {
  if (is.null(id)) {
    stop("Please choose an ID for fetching pVL data.")
  }
    return(
      labkey.selectRows( 
        baseUrl="https://prime-seq.ohsu.edu",  
        folderPath="/Labs/Bimber/Collaborations/SIV_Studies",  
        schemaName="study",  
        queryName="viralloads",     colSelect="Id,date,timePostSivChallenge/daysPostInfection,assayType,target,result,units,lod,dataSource,artInformation/daysPostArtInitiation,artInformation/daysPostArtRelease,timePostSivChallenge/infectionDate,artInformation/artInitiation,artInformation/artRelease",  
        colSort="-artInformation/artInitiation,Id,-date",  
        colFilter=makeFilter(c("sampleType", "EQUAL", "Plasma"), c("target", "EQUAL", "SIV"), c("Id", "EQUAL", id)),  
        colNameOpt="rname"
      )
    )
}

Run <- function(ids = NULL) {
  if (is.null(ids)) {
    stop("Please provide one or more IDs to process.")
  }

  all_summaries <- list()
  all_plots <- list()

  for (id in ids) {
    df <- tryCatch({
      .GetData(id)
    }, error = function(e) {
      warning("Failed to fetch data for ID: ", id, ". Skipping.")
      return(NULL)
    })

    if (is.null(df) || nrow(df) == 0) {
      next
    }

    id_summaries <- list()
    id_plots <- list()

    res <- .ChronicPhaseSetpoint(df)
    df <- res$df
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    res <- .AcutePhasePeak(df)
    df <- res$df
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    res <- .OnARTBlipFrequency(df)
    df <- res$df
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    res <- .TimeToRebound(df)
    df <- res$df
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    res <- .PostReboundSetPoint(df)
    df <- res$df
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    res <- .AcutePhaseBurden(df)
    id_summaries <- append(id_summaries, list(res$summary))
    id_plots <- append(id_plots, list(res$plot))

    all_summaries <- append(all_summaries, list(dplyr::bind_rows(id_summaries)))
    all_plots[[id]] <- id_plots
  }

  combined_summary <- dplyr::bind_rows(all_summaries)

  return(list(
    summary = combined_summary,
    plots = all_plots
  ))
}

UploadPVLOutcomes <- function(df) {
  if (is.null(df) || nrow(df) == 0) {
    stop("No rows to upload.")
  }

  df <- dplyr::rename(df, dataSource = datasource)
  
  required_cols <- c("id", "date", "outcome", "numericValue", "stringValue", "comments", "dataSource")
  missing_cols <- setdiff(required_cols, names(df))
  if (length(missing_cols) > 0) {
    stop("Missing required columns in df: ", paste(missing_cols, collapse = ", "))
  }

  upload_df <- df %>%
    dplyr::transmute(
      Id = id,
      date = as.character(date),
      outcome = outcome,
      numeric_value = numericValue,
      string_value = stringValue,
      comments = comments,
      dataSource = dataSource
    )

  Rlabkey::labkey.insertRows(
    baseUrl = "https://prime-seq.ohsu.edu",
    folderPath = "/Labs/Bimber/Collaborations/SIV_Studies",
    schemaName = "study",
    queryName = "pvl_outcomes",
    toInsert = upload_df
  )

  message("Uploaded ", nrow(upload_df), " rows to pvl_outcomes.")
}

RunAndSaveImages <- function(ids = NULL, folder_path = NULL) {
  if (is.null(ids)) stop("You must provide a vector of ids.")
  if (is.null(folder_path)) stop("You must provide a folder path.")
  if (!dir.exists(folder_path)) dir.create(folder_path, recursive = TRUE)

  all_tables <- list()

  for (id in ids) {
    message("Processing ID: ", id)
    res <- Run(id)
    
    summary_with_id <- res$summary
    summary_with_id$id <- id
    all_tables[[id]] <- summary_with_id

    plots_with_borders <- lapply(res$plots[[id]], function(p) {
      if (is.null(p)) {
        ggplot() +
          theme_void() +
          theme(
            plot.background = element_rect(color = "black", size = 1),
            panel.background = element_rect(fill = "grey90", color = NA)
          ) +
          annotate("text", x = 0.5, y = 0.5, label = "No Data", size = 6)
      } else {
        p + theme(plot.background = element_rect(color = "black", size = 1))
      }
    })

    if (length(plots_with_borders) > 0) {
      plot <- wrap_plots(plots_with_borders, ncol = 2) +
        plot_layout(guides = "collect") & 
        theme(plot.margin = margin(10, 10, 10, 10))

      file_path <- file.path(folder_path, paste0(id, ".png"))
      ggsave(filename = file_path, plot = plot, width = 18, height = 16, dpi = 300)
    }
  }

  combined_table <- dplyr::bind_rows(all_tables)
  return(combined_table)
}

df <- RunAndSaveImages(ids = ids, folder_path = "~/work/pvl-stats-output")
primeseq_res <- UploadPVLOutcomes(df)


```
